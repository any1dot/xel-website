<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[xel.org]]></title><description><![CDATA[Decentralized Grid-computing]]></description><link>https://xel.org/</link><image><url>https://xel.org/favicon.png</url><title>xel.org</title><link>https://xel.org/</link></image><generator>Ghost 1.24</generator><lastBuildDate>Sat, 28 Jul 2018 04:21:12 GMT</lastBuildDate><atom:link href="https://xel.org/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[A Brief Introduction]]></title><description><![CDATA[From grid-computing, to cloud-computing, to XEL: this section is intended to be a basic overview of what XEL is, what it is capable of and how it works on the high level.]]></description><link>https://xel.org/in-a-nutshell-what-is-xel/</link><guid isPermaLink="false">5b532c7a58bba0227b1c19a5</guid><category><![CDATA[Basic Information]]></category><dc:creator><![CDATA[Administrator]]></dc:creator><pubDate>Thu, 26 Jul 2018 11:30:00 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1415569456588-0d95cbb8c0b3?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=1080&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ&amp;s=05a48253a4ca61385912d7d8b1a6bd15" medium="image"/><content:encoded><![CDATA[<div class="kg-card-markdown"><h4 id="theproblem">The Problem</h4>
<img src="https://images.unsplash.com/photo-1415569456588-0d95cbb8c0b3?ixlib=rb-0.3.5&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ&s=05a48253a4ca61385912d7d8b1a6bd15" alt="A Brief Introduction"><p>Many scientific problems, e.g., the simulation of quantum mechanics, the non-linear optimization used in weather forecasting and the optimization and minimization of logic circuits, require computing resources that exceed those of any single computer by many orders of magnitude. The increasing adoption of these methods in today's science has been the driving force behind finding ways to create environments where these problems can be solved in a reasonable amount of time. As early as in the 1990s the term &quot;grid computing&quot; emerged; an approach that comprises pooling the computational resources of many individual computers into one holistic entity which can deliver its combined computational power as easy as accessing power from the grid (&quot;<a href="https://scpe.org/index.php/scpe/article/view/192">The Grid: Blueprint for a new computing infrastructure</a>&quot;).</p>
<h4 id="thedatacenterinourhomes">The Data-Center in Our Homes</h4>
<p>While setting up a local grid-computing cluster seems very straight-forward, it comes at a considerable cost. Not only do you have to purchase enough equipment to deliver the resources you need, but you also have to pay the recurring costs for maintenance and operation. This is not a very economical way for occasional calculations and one-time projects. A few approaches to decentralize grid computing, however, have been presented in the late 90s and build upon the fact that lots of people today have very powerful computers which are all connected to the internet. If you think about it, there is a considerable amount of computing power – not in supercomputer centers or laboratories but peoples houses. Platforms like <a href="https://en.wikipedia.org/wiki/Distributed.net">Distributed.net</a> and later <a href="https://setiathome.berkeley.edu/sah_papers/CISE.pdf">SETI@Home</a> and <a href="http://www2.cs.uh.edu/~jaspal/cosc7397/06papers/boinc.pdf">BOINC</a> have shown ways to use these (user's) devices to form a more powerful grid-computer with almost no initial setup costs. However, these platforms mostly relied on (and rely on) on volunteer computing, i.e., on volunteering participants that are willing to contribute their computational power to projects they aspire. Needless to say, that more boring projects (such as your homework assignment simulation) have only little chances to pull in any reasonable amount of computing resources.</p>
<h4 id="thisgapisclosedbyxel">This Gap is Closed by XEL</h4>
<p>While cloud-computing, a term which was first introduced in 2007, solved these issues, it mostly boils down to renting computational resources &quot;in the cloud&quot; from commercial providers. While these services are very reliable, scale very well and are easy to access, there is no real way of telling whether the prices are justified or not - renting 1000 instances for a day from one of the major cloud computing platforms will still cost plenty of money. Also, it will - in most cases - require you to create a work distribution and management logic, to coordinate your instances properly. Our project shows an alternative path to grid-computing &quot;for everyone&quot; and comprises the adaptation of all scientific advancements, which have been made since the 1990s, to the Blockchain. Similar to SETI@Home and BOINC, the work distribution is already handled by the XEL software. While being a significant contribution to ongoing and future Blockchain research, it has the potential to offer value to users, who currently need computational resources, as well. Here, no longer do the centralized providers decide about the fair value of a certain amount of computational power - the wisdom of the crowd does.</p>
<p>XEL, effectively, bundles the computation power of all connected nodes (that have the computation engine running - opt-in) and distributes it through Blockchain technology to self-coded, arbitrary tasks that can be coded by anyone using XEL’s own trustless programming language ePL. In this eco-system, nodes with powerful hardware are incentivized to contribute their unused computational resources by being rewarded with crypto-currency payments. Thinking in terms of Blockchain, this process can be thought of as a form of &quot;mining,&quot; similarly to the process of mining traditional crypto-currencies such as Bitcoin.</p>
</div>]]></content:encoded></item><item><title><![CDATA[Installing Xeline Wallet]]></title><description><![CDATA[Xeline is a wallet software which lets you easily upload your ePL file to the XEL network by just drag-dropping it into the GUI. It takes only a few seconds to have the computation nodes on the XEL network start searching for solutions to your algorithm. ]]></description><link>https://xel.org/xeline-wallet/</link><guid isPermaLink="false">5b58631ca7fe25cab6d3c50d</guid><category><![CDATA[Installation Guide]]></category><dc:creator><![CDATA[Administrator]]></dc:creator><pubDate>Wed, 25 Jul 2018 11:47:06 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1512415047789-055da07059ee?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=1080&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ&amp;s=c136bdb61dfba0ea39b3c6117d95f751" medium="image"/><content:encoded><![CDATA[<div class="kg-card-markdown"><img src="https://images.unsplash.com/photo-1512415047789-055da07059ee?ixlib=rb-0.3.5&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ&s=c136bdb61dfba0ea39b3c6117d95f751" alt="Installing Xeline Wallet"><p>Xeline is a tool that comes in handy when you have finished implementing your ePL program and you feel it is ready to be broadcast to the XEL network. Xeline basically is a wallet software which lets you easily upload your ePL file to the XEL network by just drag-dropping it into the GUI. It takes only a few seconds to have the computation nodes on the XEL network start searching for solutions to your algorithm. Furthermore, this wallet is able to conveniently perform live monitoring of your open tasks and gathers + collects the results that other nodes have found and recorded on the Blockchain. The installation is straightforward.</p>
<h2 id="binaryinstallation">Binary Installation</h2>
<h4 id="windows">Windows</h4>
<p>Download the latest Windows Setup file from:</p>
<pre><code>https://github.com/xel-software/xeline/releases/latest
</code></pre>
<p>Launch the Setup file; the installation will be conducted automatically in the background. Once you see the Xeline window, follow the instructions on the screen.</p>
<p>When you run the XelineSetup.exe, you might get a security warning. Just click on &quot;more info&quot; and then on &quot;run anyway&quot; to continue with the installation.</p>
<h4 id="macos">MacOS</h4>
<p>Download the latest Xeline.dmg from:</p>
<pre><code>https://github.com/xel-software/xeline/releases/latest
</code></pre>
<p>Open it, and drag Xeline.app to your &quot;Application&quot; folder. When running for the first time, you might get a security warning. If so, go into your /Applications folder using Finder, right click on Xeline.app click &quot;Open&quot; in the menu and follow the instructions on the screen.</p>
<h4 id="linux">Linux</h4>
<p>This tutorial covers the installation on Ubuntu based distributions. The process, however, should be adaptable to any other distribution.</p>
<p>First make sure you have all necessary dependencies installed:</p>
<pre><code>sudo apt-get install -y unzip
</code></pre>
<p>Download the latest linux zip archive from:</p>
<pre><code>https://github.com/xel-software/xeline/releases/latest
</code></pre>
<p>Now, unzip the archive:</p>
<pre><code>unzip xeline-linux.zip
</code></pre>
<p>Now, you can go into the folder you just extracted and launch Xeline:</p>
<pre><code>cd Xeline-linux-x64
./Xeline
</code></pre>
<p>Once you see the Xeline window, follow the instructions on the screen.</p>
<h2 id="sourcecodeinstallation">Source Code Installation</h2>
<p>In this section, we just provide instructions for the installation on Ubuntu-based systems. The process should be very similar on other Linux distributions and other operating systems.</p>
<p>Make sure curl and git are installed</p>
<pre><code>sudo apt-get install -y curl git
</code></pre>
<p>Install a recent version of nodejs first, if you haven't already.</p>
<pre><code>curl -sL https://deb.nodesource.com/setup_9.x | sudo -E bash -
sudo apt-get install -y nodejs
</code></pre>
<p>Get the repository:</p>
<pre><code>git clone https://github.com/xel-software/xeline.git
</code></pre>
<p>If you already have it, cd into the directory containing your Xeline sources and update the code by using these commands:</p>
<pre><code>cd xeline
git pull
</code></pre>
<p>Now, go into the directory containing your Xeline sources and install all dependencies (needs to be done only once)</p>
<pre><code>cd xeline
npm install
</code></pre>
<p>And finally, run the application:</p>
<pre><code>npm start
</code></pre>
</div>]]></content:encoded></item><item><title><![CDATA[Installing the Miner]]></title><description><![CDATA[This tool is the core of the entire XEL network. Opposed to what the name suggests, it is way more than just a miner. It is also a fully fledged ePL to C conversion and compilation tool, and is essential to have when developing apps.]]></description><link>https://xel.org/installing-the-miner/</link><guid isPermaLink="false">5b585e9ea7fe25cab6d3c50a</guid><category><![CDATA[Installation Guide]]></category><dc:creator><![CDATA[Administrator]]></dc:creator><pubDate>Wed, 25 Jul 2018 11:28:46 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1507228060299-33b5fcb63bc6?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=1080&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ&amp;s=636b5941ab53eea2448cb12a7e95c35a" medium="image"/><content:encoded><![CDATA[<div class="kg-card-markdown"><img src="https://images.unsplash.com/photo-1507228060299-33b5fcb63bc6?ixlib=rb-0.3.5&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ&s=636b5941ab53eea2448cb12a7e95c35a" alt="Installing the Miner"><p>This tool is the core of the entire XEL network. Opposed to what the name suggests, it is way more than just a miner. It is a fully fledged ePL to C conversion and compilation tool and helps you to convert your ePL program to C, compile it into executable machine code and natively execute your ePL programs on your local machine. On top of that, it allows you to pull work from other scientists on the XEL network and search for solutions to their algorithms. Once a solution is found, xel_miner is capable of submitting it to the network in exchange for cryptocurrency rewards. It is not required to develop and submit jobs to the XEL network, however, it is a very hand tool for debugging purposes.</p>
<h2 id="windows">Windows</h2>
<p>Download the latest (experimental CPU only) binary version from the following Github releases page:</p>
<pre><code>https://github.com/xel-software/xel_miner_releases/files/1933994/xel_miner-0.9.6.zip
</code></pre>
<p>After you unzip the archive, go into the folder xel_miner-0.9.6/xel_miner. There, you will find the xel_miner.exe executable. You can test if it’s functioning properly by running:</p>
<pre><code>xel_miner.exe --test-vm examples\SHA256_BTC.epl
</code></pre>
<p>If you encounter any errors, the reason may be that you already have a MinGW installation on your system and in your PATH. This may interfere with the packages stipped down MinGW environment. In this case, try to clean the PATH variable by doing a simple:</p>
<pre><code>set PATH=
</code></pre>
<p>The build-process on Windows is somewhat &quot;messy&quot;, so we do not provide instructions on building that software from sources at this point. We are happy to publish a guide if the community comes up with a reliable and reproducible way.</p>
<p>You can now switch to the programming section (accessible from the top menu) to start learning how to develop algorithms for the XEL blockchain, or getting more information on how to use the mining software properly.</p>
<h2 id="macos">MacOS</h2>
<p>Make sure you have homebrew installed (if you do, skip this step):</p>
<pre><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre>
<p>Now, you can use Homebrew to install all required build dependencies:</p>
<pre><code>brew install gmp make cmake openssl
</code></pre>
<p>At this point it might be wise to check whether you have your GPU SDK (Cuda, OpenCL) along with the proper drivers installed in order to compile xel_miner with GPU support. If you don't want to worry about this at the moment, just go with the CPU version for now.</p>
<p>In the next step, make sure you check out the latest source code version from Github:</p>
<pre><code>git clone https://github.com/xel-software/Miner-Mainnet.git xel_miner
</code></pre>
<p>For some reason, the libssl directory is not being linked to the proper location. You can fix this by simply running:</p>
<pre><code>ln -s /usr/local/opt/openssl/include/openssl/ /usr/local/include/openssl
</code></pre>
<p>Now, you can go ahead and build the miner:</p>
<pre><code>cd xel_miner
OPENSSL_ROOT_DIR=/usr/local/opt/openssl cmake .
make
</code></pre>
<p>You can test if it’s functioning properly by running:</p>
<pre><code>xel_miner --test-vm examples/SHA256_BTC.epl
</code></pre>
<p>You can now switch to the programming section (accessible from the top menu) to start learning how to develop algorithms for the XEL blockchain, or getting more information on how to use the mining software properly.</p>
<h2 id="linux">Linux</h2>
<p>As it is nearly impossible to cover all currently available linux distributions, we will cover the installation for Ubuntu based systems. While the individual dependencies might have a slightly different name, the entire process should be easily adaptable to any distribution out there.</p>
<p>In a first step, make sure you have all dependencies installed:</p>
<pre><code>sudo apt-get install git libgmp-dev libcurl4-openssl-dev libssl-dev build-essential cmake
</code></pre>
<p>At this point it might be wise to check whether you have your GPU SDK (Cuda, OpenCL) along with the proper drivers installed in order to compile xel_miner with GPU support. If you don't want to worry about this at the moment, just go with the CPU version for now.</p>
<p>Now, please make sure you check out the latest source code version from Github:</p>
<pre><code>git clone https://github.com/xel-software/Miner-Mainnet.git xel_miner
</code></pre>
<p>Now use cmake and make to gernerate the Makefile and compile the software:</p>
<pre><code>cd xel_miner
cmake .
make
</code></pre>
<p>You can now switch to the programming section (accessible from the top menu) to start learning how to develop algorithms for the XEL blockchain, or getting more information on how to use the mining software properly.</p>
</div>]]></content:encoded></item><item><title><![CDATA[Potential Use-Cases]]></title><description><![CDATA[This article give you a deeper look into how XEL works and what kind of use-cases could be suitable for running on the XEL Blockchain.]]></description><link>https://xel.org/potential-use-cases/</link><guid isPermaLink="false">5b5a7589352c821dce608fd7</guid><category><![CDATA[Basic Information]]></category><dc:creator><![CDATA[Administrator]]></dc:creator><pubDate>Wed, 25 Jul 2018 01:30:00 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1527409335569-f0e5c91fa707?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=1080&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ&amp;s=a7dfe365d0259a816ca47b35f5559948" medium="image"/><content:encoded><![CDATA[<div class="kg-card-markdown"><img src="https://images.unsplash.com/photo-1527409335569-f0e5c91fa707?ixlib=rb-0.3.5&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ&s=a7dfe365d0259a816ca47b35f5559948" alt="Potential Use-Cases"><p>Writing is down right now ...</p>
</div>]]></content:encoded></item><item><title><![CDATA[Part 1: Your First XEL Program]]></title><description><![CDATA[If you are looking for a step-by-step guide to get started which programming highly parallel applications on XEL, this is the place where you should begin.]]></description><link>https://xel.org/programming-first-steps/</link><guid isPermaLink="false">5b5332b362992e27235e25bf</guid><category><![CDATA[Learn Programming]]></category><dc:creator><![CDATA[Administrator]]></dc:creator><pubDate>Tue, 24 Jul 2018 11:30:00 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1521321205814-9d673c65c167?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=1080&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ&amp;s=cbe2f1e4818e849025de2e5c70d86401" medium="image"/><content:encoded><![CDATA[<div class="kg-card-markdown"><h2 id="quickintroduction">Quick Introduction</h2>
<img src="https://images.unsplash.com/photo-1521321205814-9d673c65c167?ixlib=rb-0.3.5&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ&s=cbe2f1e4818e849025de2e5c70d86401" alt="Part 1: Your First XEL Program"><p>This tutorial is designed for software programmers with a need to understand the ePL programming language starting from scratch. You will gain enough knowledge from where you can take yourself to a higher level of expertise. Let us give you a brief overview of what ePL is: ePL is a programming language which was designed explicitly for coding algorithms to be executed on the XEL computation node network. Its syntax is very similar to the C programming languages. However, since nodes on the XEL network download and execute code from potentially dangerous sources a few adaptations were necessary to ensure that code written in ePL can cause no harm to the system it is executed on. Furthermore, since task distribution and verification is done in a decentralized fashion (all nodes which meet a minimum system requirement in terms of memory and CPU power must be able to verify the algorithms’ results in a similar amount of time) is it designed to run in a resource-limited VM. Furthermore, ePL has a slightly modified memory management (and instruction set) which ensures that every node can assess how much memory the program will consume and when it will terminate before execution. This avoids unpredictable behavior such as out of memory errors and the halting problem. However, before we get too deep into the little details, you should make sure you have installed all components as described in the &quot;Installation&quot; section.</p>
<h2 id="asimpleexamplefindingprimenumbers">A Simple Example: Finding Prime Numbers</h2>
<p>The example we will be looking at is a simple ePL program which is meant to find prime numbers between 10000 – 20000. While it has no real relevance for the real world, it certainly is small enough to help in understanding how ePL works. First of all, let us take a look at the entire code before we start breaking down each line of it:</p>
<pre><code>array_uint 1000;

function main {
    verify();
} 

function primetest {
    u[1] = 0;
    if (u[2] &lt;= 1)  u[1]=0;
    else if (u[2] &lt;= 3) u[1]=0;
    else if (u[2]%2 == 0 || u[2]%3 == 0) u[1]=0;
    else {
        u[3]=5;
        u[1]=1;
        repeat(u[99],20000,20000){
        if (u[2]%u[3] == 0 || u[2]%(u[3]+2) == 0)
        { u[1]=0; break; }
        if(u[3]*u[3] &gt; u[2]) break;
            u[3]+=6;
        }
    }
}
function verify {
    // make prime test
    u[2] = m[0];
    u[1]=0;
    if(m[0]&gt;10000 &amp;&amp; m[0]&lt;20000) primetest();
    verify_bty ((m[0]&gt;10000 &amp;&amp; m[0]&lt;20000) &amp;&amp; (u[1]==1));

    // some randomness for POW function
    u[57] = m[1];
    u[56] = m[2];
    u[55] = m[3];
    u[54] = m[4];

    verify_pow (u[57], u[56], u[55], u[54]);
}
</code></pre>
<p>An ePL program usually starts with memory allocations which basically describe how the following six arrays are being allocated:</p>
<pre><code>int i[] : signed ints (32 bit)
int u[] : unsigned ints (32 bit)
int l[] : signed longs (64 bit)
int ul[] : unsigned longs (64 bit)
int d[] : doubles
int f[] : floats
</code></pre>
<p>Your ePL program should have these 6 array initializers at the beginning, each one telling the VM how many elements it should allocate in which array. In this example it is:</p>
<pre><code>array_int 0;
array_uint 1000;
array_long 0;
array_ulong 0;
array_double 0;
array_float 0;
</code></pre>
<p>Lines that allocate 0 elements to an array can be left out – this has been done in our example above. The arrays themselves do not need (and must not be) allocated by the programmer. The command array_int 1000; will already make sure that I[] is created with 1000 elements in it (indices 0 – 999). Please keep in mind, that there is no such concept as variable scopes, all arrays are global. Later, you will learn that this does not necessarily make it harder to code in ePL – be a little patient 🙂 In the next part, the body of your ePL program, you can define multiple functions. Functions have the following syntax:</p>
<pre><code>function name {
    ...
}
</code></pre>
<p>Functions neither have arguments nor return values. This is not a big issue though since arguments and return values can be mimicked by merely using the global arrays. Again, later on, you will see how you still can easily and comfortably code in the way you are used to right now.</p>
<p>In our example we have defined three functions: main, verify and test_prime. While you can define as many functions are you like (as long as you stay within the maximum allowed complexity and size allowed for your program), you must have the main and the verify function.</p>
<p>The functions main and verify are needed both because ePL allows for an asymmetric calculation verification. To understand this a bit better, it is crucial to understand how working nodes are searching for solutions and how the rest of the network verifies these result to make sure that a scientist, who purchases computational power on XEL, actually gets what he has paid for: a correct result. Workers, those nodes who are searching for solutions to other tasks, are executing the main function whereas the verification of a solution to the algorithm is done by executing verify().</p>
<p>This has a very good reason: XEL allows you more complex programs with a reasonably longer execution time inside the main function that it does for the verification routine to ensure a smooth and lightweight verification on the nodes without stalling the network for too long. A good example where this asymmetrical verification could come in handy is an SAT solver. The main() function would carry a complex SAT solving logic, which is more expensive to execute, whereas the verification routine would assign the result to the boolean formula and check if it evaluates to true. If you want to see an example of how this can be done, feel free to take a look at our SAT solving demo.</p>
<p>Urgent warning: It is the developer's responsibility to code the logic in main and verify correctly. Mainly, it is essential to make sure that the logic (in particular, the verify_bty logic which we will read more about later on) in verify evaluates to true whenever the one in main evaluates to true. An incorrect implementation by the developer might cause results to be accepted, that does not reflect your desired outcome. Even more importantly, it can cause the Blockchain rejects valid results that have been found in main because they do not pass verify. Admittedly, this sounds still very abstract to you, but it will make more sense as we dig deeper into this tutorial.</p>
<p>For now, things are straightforward: in our particular case, there is no possibility to do an asymmetrical verification as finding primes is as complex as verifying them. To keep the code clean, we, therefore, add the entire logic into verify(), and let the main function call verify():</p>
<pre><code>function main {
    verify();
}
</code></pre>
<p>Let’s start taking a look at the verify function:</p>
<pre><code>function verify {
    // make prime test
    u[2] = m[0];
    u[1]=0;
    if(m[0]&gt;10000 &amp;&amp; m[0]&lt;20000) primetest();
    verify_bty ((m[0]&gt;10000 &amp;&amp; m[0]&lt;20000) &amp;&amp; (u[1]==1));

    // some randomness for POW function
    u[57] = m[1];
    u[56] = m[2];
    u[55] = m[3];
    u[54] = m[4];

    verify_pow (u[57], u[56], u[55], u[54]);
}
</code></pre>
<p>Before you can understand what is going on here, it is essential that you understand how randomness is introduced into the execution of your code. ePL has one more array, the so-called uint m[12]; array – an array which consists of 12 unsigned integers. The first 10 unsigned integers are pseudo-random and provide you with 320 bits of entropy in total. m[10], the 11th unsigned integer, contains the round number and m[11], the 12th unsigned integer, contains the iteration that we are currently in. The concept of iterations will be explained at a later point in time. To better understand what is going on here, please take a look at the internal C logic that fills this uint m[12]; array:</p>
<pre><code>// hash32[] is a random hash value provided by the protocol
// mult32[] is other information such as round and iteration 

// Randomize Inputs m[0]-m[9]
for (i = 0; i &lt; 10; i++) {
  work-&gt;vm_input[i] = swap32(hash32[i % 4]);
  if (i &gt; 4)
    work-&gt;vm_input[i] =
             work-&gt;vm_input[i] ^ work-&gt;vm_input[i - 3];
}

// Set m[10] To Round Number
work-&gt;vm_input[10] = mult32[1];
// Set Inputs m[11] To Iteration Number
work-&gt;vm_input[11] = mult32[2];
</code></pre>
<p>In our particular example, we will use the first integer m[0] to pick our prime candidate. Of course, you can use the entire 320 bit to create potential solution candidates to your algorithm. If you need more than 320 bit, you can even derive an infinite pseudo-random number stream from it:</p>
<pre><code>u[2] = m[0];
u[1]=0;
</code></pre>
<p>In this part, we take over the first random value in m[0] and store it in one of our unsigned int array slots u[0] – remember, we have defined 1000 of them at the top of our program. Additionally, we initialize u[1] with the value 0: this slot will later hold the result of the prime-check.</p>
<pre><code>if(m[0]&gt;10000 &amp;&amp; m[0]&lt;20000) primetest();
</code></pre>
<p>In this part, we want to call the function conducting the prime test. Since we are only interested in primes between 10000 and 20000, we only need to call that function if the value in m[0] meets this requirement.</p>
<pre><code>verify_bty ((m[0]&gt;10000 &amp;&amp; m[0]&lt;20000) &amp;&amp; (u[1]==1));
</code></pre>
<p>This part tells the backend system what to be considered a valid solution to your task/challenge – or a “bounty” how it is called in XEL’s terminology. This calls the function verify_bty () which takes a boolean expression as an argument which should evaluate to true for every valid solution that you want to have reported back. In this case, it is straightforward: if the number we have stored in m[0] is between 10000 and 20000, and the value in m[1] equals 1, then consider this a valid solution.</p>
<p>In a next step, we need to specify a condition for “proof-of-work” payments. XEL’s Blockchain works in a way that every task has two types of payments: the proof-of-work payments and the bounty payments. This has a very simple reason: very often, bounties are very hard to find and only limited to a hand full per job. Imagine you want to find an input to a CNF formula that evaluates it to true: if you have a bijective relation, there will be only one solution which, depending on the complexity of your formula, is very hard to find. While the discovery of such a solution should be awarded an attractive amount of coins (to keep workers motivated) you also want to keep them motivated by frequent, smaller payments. XEL introduces the concept of proof-of-work solutions to achieve that. These are solutions that do not solve your problem but which can be submitted by the workers to claim a tiny amount of coins as a reward for ongoing commitment. As you can probably imagine, payments per bounty should be set significantly higher than payments per proof-of-work. However, if you set this value too small, other tasks on the network might seem more lucrative and attract the processing power away from you. Proof-of-work packages, by the way, work on top of a re-targeting mechanism comparable to the block difficulty re-target in Bitcoin: The more processing power the network has, the harder it becomes to find such proof-of-work solutions so that, on average, the total number of proof-of-work solutions in the entire network converges to 10 per minute.</p>
<p>It is important to point out that it is the developer’s responsibility to provide the verify_pow() function with enough “evidence” that the worker has been actually working on your problem in the form of four unsigned integers. In our example here, we use this:</p>
<pre><code>// some randomness for POW function
u[57] = m[1];
u[56] = m[2];
u[55] = m[3];
u[54] = m[4];

verify_pow (u[57], u[56], u[55], u[54]);
</code></pre>
<p>Now, while it is more than fine for our little demo, it is an example of the worst way to do it for productive use. Here, we take four integers from our random input entropy and use them to specify the proof-of-work reward condition. In this case, workers who are not interested in getting the bounty payments but want to work towards the proof-of-work solutions can omit the entire program logic and only check input integers m[1] ... m[4] to see if they have found a proof-of-work solution. This gives them a massive advantage over the more honest workers and allows them to get paid without really contributing anything useful to your task. It is always a best practice to use four values which depend “somehow” on the execution on as most of the program’s logic as possible. Then, only people who run the entire code can find those bounties. While this still does not guarantee that they will submit any bounty, there is no real reason why they shouldn’t since they have already performed all the work required for a bounty check. In the last step, we are going to take a look at the actual prime check:</p>
<pre><code>function primetest {
    u[1] = 0;
    if (u[2] &lt;= 1)  u[1]=0;
    else if (u[2] &lt;= 3) u[1]=0;
    else if (u[2]%2 == 0 || u[2]%3 == 0) u[1]=0;
    else {
        u[3]=5;
        u[1]=1;
        repeat(u[99],20000,20000){
        if (u[2]%u[3] == 0 || u[2]%(u[3]+2) == 0)
        { u[1]=0; break; }
        if(u[3]*u[3] &gt; u[2]) break;
            u[3]+=6;
        }
    }
}
</code></pre>
<p>What you see here is a simple trial-division based primacy check which works on m[2] (we have stored there our prime candidate before) as the input and sets m[1] = 1 if the candidate is a prime number, and m[1] = 0 otherwise. This value can be considered the “return value” of our function. One novelty you have probably noticed is the strange loop construct that you have probably never seen before:</p>
<pre><code>repeat(u[99],20000,20000){
...
}
</code></pre>
<p>Before digging deeper into the characteristics of ePL’s loops, we need to take a look at what makes loops so evil. Remember, we want to have a programming language where it is known beforehand when it will terminate and how much memory it will use to avoid all sorts of DOS attacks where tasks are submitted that never terminate. However, why is it so hard to assess this with traditional loops? Well, traditional loops suffer from the so-called halting problem. The halting problem mainly is the problem of determining whether a program will terminate or whether it will run forever. While it is possible to do it for a C loop like this</p>
<pre><code>for(int i=0; i&lt;1000: ++i){
   ...
}
</code></pre>
<p>it already becomes impossible for simple constructs like this</p>
<pre><code>int entropy = rand();
for(int i=0; i&lt;1000: ++i){
   if (entropy &lt; 10000) --i; if (entropy &gt; 50000) ++i;
   ...
}
</code></pre>
<p>Here, the termination of the for loop is depending on the value of entropy. Of course, in this simple example, we can see with our own eyes what is going to happen. If entropy &lt; 10000 then the loop runs forever. If 10000 &lt;= entropy &lt;= 50000, then the loop iterates exactly 1000 times, and for entropy &gt; 50000 only 500 times. For the general case, however, there is no efficient way to algorithmically tell whether a C program will terminate, and when.</p>
<p>To eliminate this issue, ePL introduces a loop in the form of:</p>
<pre><code>repeat(index,iterations,max_iterations){
...
}
</code></pre>
<p>Where the index is an array slot, the iteration is an expression which may be constant but which also may be an array slot of your choice, and the max_iterations is a constant value giving a maximum amount of iterations after which the loop exits. Internally, when translated back to C, our loop</p>
<pre><code>repeat(u[99],20000,20000){
...
}
</code></pre>
<p>translates to</p>
<pre><code>int counter = 0; // immutable by user's code
u[99]=0;
for(int i=0; i&lt;20000; ++i){
    ...
    counter++;
    u[99] = counter;
    if(counter==20000) break;
}
</code></pre>
<p>The counter variable cannot be changed by the ePL code itself and will count to the maximum iteration count before it causes the loop to exit – regardless of what your code does. When parsing your code and checking if the complexity of your code is within certain bounds, it will always be assumed that your loop will run for the maximum amount of iterations that you have specified. Make sure to specify a sufficiently large number here, or your loops will exit prematurely.</p>
<h2 id="firstcompilation">First Compilation</h2>
<p>Now, that you have written your first program in ePL. Now, it’s time to test it. To test your program for syntactical correctness, you can use xel_miner. Assuming your program is called find_prime.epl, you can use this command to do the first run of your code:</p>
<pre><code>./xel_miner --validate --test-avoidcache
                       --test-vm find_prime.epl
</code></pre>
<p>. The --validate flag tells xel_miner to look for the use of uninitialized variables which are not guaranteed to be zero at all times. You want to avoid that behavior. Furthermore, programs that do not pass this check will not be accepted on the Blockchain. The --test-vm flag tells xel_miner not to start mining, but to run (and check it for correctness) a local ePL file on your computer. If everything goes well, you will be presented with an output like this:</p>
<pre><code>** Elastic Compute Engine **
   Miner Version: 0.9.6
   ElasticPL Version: 0.9.4
[16:31:29] DEBUG: Skipping recompilation to be blazing fast
[16:31:29] DEBUG: TestVM: block id '123456789'
[16:31:29] DEBUG: TestVM: work id '987654321'
[16:31:29] DEBUG: WCET main tester status: OFF
[16:31:29] DEBUG: WCET verify tester status: OFF
[16:31:29] DEBUG: TestVM: multiplicator '0000......0000'
[16:31:29] DEBUG: TestVM: pubkey '0000......0000'
[16:31:29] DEBUG: TestVM: target '0FFF......FFFF'
[16:31:29] DEBUG: storage size: 0
[16:31:29] DEBUG: Library 'job_987654321' Loaded
[16:31:29] DEBUG: Bounty Found: false
[16:31:29] DEBUG: POW Found: false
[16:31:29] DEBUG: POW Hash: 4E95CBA872172C0596BE7CB482703EE4
[16:31:29] DEBUG: Compiler Test Complete
[16:31:29] Exiting xel_miner
[16:31:29] Cleaning up
</code></pre>
<p>If everything went well, and you didn’t receive any compilation errors, it means that your code is syntactically correct – does not yet tell us much about whether it is doing what you want to do; this is something we will test later. However, first of all, you might be interested in how your program looks like when compiled into C. You can take a look by running:</p>
<pre><code>cat work/job_987654321.h
</code></pre>
<p>The output will look like this:</p>
<pre><code>void main_987654321(uint32_t * , uint32_t, uint32_t * ,
    uint32_t * , uint32_t * );
void primetest_987654321();
void verify_987654321(uint32_t * , uint32_t, uint32_t * ,
    uint32_t * , uint32_t * );

void main_987654321(uint32_t * bounty_found,
    uint32_t verify_pow, uint32_t * pow_found,
    uint32_t * target, uint32_t * hash) {
    verify_987654321(bounty_found, verify_pow,
        pow_found, target, hash);
}

void primetest_987654321() {
    u[1] = 0;
    if ((u[2]) &lt;= (1)) {
        u[1] = 0;
    } else {

        if ((u[2]) &lt;= (3)) {
            u[1] = 0;
        } else {
            if ((((((2) != 0) ? (u[2]) % (2) : 0)) == (0)) ||
                (((((3) != 0) ? (u[2]) % (3) : 0)) == (0))) {
                u[1] = 0;
            } else {
                u[3] = 5;
                u[1] = 1;
                int loop87;
                for (loop87 = 0; loop87 &lt; (20000); loop87++) {
                    if (loop87 &gt;= 20000) break;
                    u[99] = loop87;
                    if ((((((u[3]) != 0) ? (u[2]) % (u[3]) : 0))
                        == (0)) ||
                        ((((((u[3]) + (2)) != 0) ?
                                (u[2]) % ((u[3]) + (2)) : 0)) ==
                            (0))) {
                        u[1] = 0;
                        break;
                    }
                    if (((u[3]) * (u[3])) &gt; (u[2])) {
                        break;
                    }
                    u[3] += 6;
                }
            }
        }
    }
}

void verify_987654321(uint32_t* bounty_found,uint32_t verify_pow,
    uint32_t* pow_found, uint32_t* target, uint32_t* hash) {
    u[2] = m[0];
    u[1] = 0;
    if (((m[0]) &gt; (10000)) &amp;&amp; ((m[0]) &lt; (20000))) {
        primetest_987654321();
    }
    * bounty_found = (uint32_t)((((m[0]) &gt; (10000)) &amp;&amp;
            ((m[0]) &lt; (20000))) &amp;&amp; ((u[1]) == (1)) != 0 ? 1 :
        0);
    u[57] = m[1];
    u[56] = m[2];
    u[55] = m[3];
    u[54] = m[4];
    if (verify_pow == 1)
        *
        pow_found =
        check_pow(u[57], u[56], u[55], u[54], &amp;
            m[0], &amp; target[0], &amp; hash[0]);
    else
        *pow_found = 0;
}
</code></pre>
<p>We won’t go into detail and go through every line of it. Rather, we wanted to show you how you can compile your ePL program into C to understand how your ePL will be translated in the end and help you debug problems that you might face during development. For now, we have just verified that your code is syntactically correct but not if it produces the correct results. You can try a test-mining run by calling xel_miner like this (important: always use –test-avoidcache to disable caching, this may cause problems during testing):</p>
<pre><code>./xel_miner --test-avoidcache --test-cont-bounty
                              --test-vm prime.epl
</code></pre>
<p>Depending on the complexity of your problem, you will have to wait some time until you get your first result. For testing purpose, it might be wise to lessen the requirements inside your verify_bty(...) call during your local testing activities to get your result quicker. In our case, the result should be displayed very quickly:</p>
<pre><code>** Elastic Compute Engine **
   Miner Version: 0.9.6
   ElasticPL Version: 0.9.4
[20:08:09] DEBUG: Skipping recompilation to be blazing fast
[20:08:09] DEBUG: TestVM: block id '123456789'
[20:08:09] DEBUG: TestVM: work id '987654321'
[20:08:09] DEBUG: WCET main tester status: OFF
[20:08:09] DEBUG: WCET verify tester status: OFF
[20:08:09] DEBUG: TestVM: multiplicator '0000....0000'
[20:08:09] DEBUG: TestVM: pubkey '0000....0000'
[20:08:09] DEBUG: TestVM: target '0FFF....FFFF'
[20:08:09] DEBUG: storage size: 0
[20:08:09] DEBUG: Library 'job_987654321' Loaded
[20:08:09] &gt;&gt; STARTING CONTINUOUS TEST
[20:08:09] &gt;&gt; THIS MAY TAKE VERY LONG DEPENDING ON YOUR PROBLEM
[20:08:17] ran 5000000 iterations, still working ...
[20:08:18] ********************************
[20:08:18] FOUND A SOLUTION TO YOUR PROBLEM
[20:08:18]  we will dump all 12 input ints
[20:08:18] ********************************
[20:08:18] m[0]    =    18503
[20:08:18] m[1]    =    3294169169
[20:08:18] m[2]    =    2082860469
[20:08:18] m[3]    =    2676999779
[20:08:18] m[4]    =    18503
[20:08:18] m[5]    =    3095193060
[20:08:18] m[6]    =    3819580374
[20:08:18] m[7]    =    2676985380
[20:08:18] m[8]    =    3095178659
[20:08:18] m[9]    =    670245767
[20:08:18] m[10]    =    0
[20:08:18] m[11]    =    1
[20:08:18] DEBUG: Bounty Found: true
[20:08:18] DEBUG: POW Found: false
[20:08:18] DEBUG: POW Hash: 6F71E050C9A3B5A4B8A5686CB47EB17E
[20:08:18] DEBUG: Compiler Test Complete
[20:08:18] Exiting xel_miner
[20:08:18] Cleaning up
</code></pre>
<p>From this line here</p>
<pre><code>[20:08:18] DEBUG: Bounty Found: true
</code></pre>
<p>You can see, that indeed a bounty has been found. Moreover, since we have used a straightforward way to define solution candidates, you can see the result right away:</p>
<pre><code>[20:08:18] m[0]    =    18503
</code></pre>
<p>Indeed, it is a prime number between 10000 and 20000. Are you ready to push your first ePL program to the Blockchain?</p>
</div>]]></content:encoded></item><item><title><![CDATA[Part 2: Broadcast to the Blockchain]]></title><description><![CDATA[This tutorial covers all aspects of publishing your highly parallel application of the XEL Blockchain and receiving solutions to right into your wallet.]]></description><link>https://xel.org/publish-your-first-program-on-the-blockchain/</link><guid isPermaLink="false">5b570add62992e27235e25cb</guid><category><![CDATA[Learn Programming]]></category><dc:creator><![CDATA[Administrator]]></dc:creator><pubDate>Tue, 24 Jul 2018 11:20:11 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1521623475836-87d82a22184f?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=1080&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ&amp;s=ffc8f1d93cbb40d8469da849a8ab7a6f" medium="image"/><content:encoded><![CDATA[<div class="kg-card-markdown"><h2 id="preparingyoureplfile">Preparing Your ePL File</h2>
<img src="https://images.unsplash.com/photo-1521623475836-87d82a22184f?ixlib=rb-0.3.5&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ&s=ffc8f1d93cbb40d8469da849a8ab7a6f" alt="Part 2: Broadcast to the Blockchain"><p>We will use the demonstration task that we've created in step 1 of this tutorial. Save it to a file called “my_own_prime_demo.epl”. While this demo is already integrated into the Xeline wallet and can be run right away, we want to create this demo project from scratch here so you can learn and understand every single step involved. At this moment, your ePL file contains just the program logic. However, to submit it to the Blockchain you have to configure a few parameters which we can “metadata. Those parameters tell Xeline how much you are willing to spend for that job, how long it is meant to be running, how many solutions you are interested in, how many iterations your job is meant to run, and so on. We have not yet covered the iteration part, we save that for later. Metadata is added to your ePL file at the top. So go ahead, an add those lines to the top of your ePL program:</p>
<pre><code>// metadata(title:My personal PRIME demo)
// metadata(pow_limit:1000)
// metadata(pow_price:0.02)
// metadata(bounty_limit:1)
// metadata(bounty_price:5)
// metadata(iterations:1)
// metadata(timeout:250)
// metadata(callback:my_own_prime_demo_callback.js)
</code></pre>
<p>Let us break this up and take a deeper look at what these lines do:</p>
<pre><code>// metadata(title:My personal PRIME demo)
</code></pre>
<p>This line gives your job description. Try to keep it as short as possible. This title is just used to help you organize tasks inside the Xeline wallet, and it won’t be transmitted to the Blockchain.</p>
<pre><code>// metadata(pow_limit:1000)
// metadata(pow_price:0.0001)
</code></pre>
<p>These two lines describe how many proof-of-work rewards you want to give out before your job times out and closes automatically. Remember: these are continuous small rewards workers keep getting as a targeted frequency of 10 proof-of-work / second (for the all tasks in the network together). So in our case, we want to close our job if we have paid 1000 proof-of-work rewards for 0.0001 XEL each and the network has not yet found a solution to our problem.</p>
<pre><code>// metadata(bounty_limit:1)
// metadata(bounty_price:5)
</code></pre>
<p>These two lines describe how many solutions you want for your problem. In our case, we are looking for just one prime number, so we set this value to 1. Also, we are willing to pay a “bounty price” of 5 XEL for the first submitted solution to our problem. If multiple solutions are submitted inside one block, only the one appearing first in the block transaction list will count. This can happen for the very simple reason that the work closing and timeout events are triggered after the block has been processed. So when your job receives a solution in block 1000, it will be closed in block 1001. However, since we can never be sure which unconfirmed transactions will make it into the next block, we cannot close the job after the first solution is put into the unconfirmed transaction cache at block height 1000. This, however, should be not of your concern. This affects “workers” who have submitted a bounty solution and wonder why they have not been rewarded.</p>
<pre><code>// metadata(iterations:1)
</code></pre>
<p>This line tells Xeline how many iterations you want your program to run. The concept of iterations will be explained in one of the next blog posts: we leave it at 1 for now, which means that your program ends immediately after #bounty_limit solutions have been found.</p>
<pre><code>// metadata(timeout:250)
</code></pre>
<p>This line tells Xeline after how many blocks you want to end your task regardless of how many proof-of-work or bounty solutions have been found. This is useful when you, for example, create tasks with time-critical results. In this example, we just set this value to a random 250 which means that the job will end after 250 blocks from the block it gets included in.</p>
<pre><code>// metadata(callback:my_own_prime_demo_callback.js)
</code></pre>
<p>This line is probably the most important one since it will help you to analyze and post-process the results the worker nodes find automatically. Remember, as you have seen in the ePL programming guide, solutions are determined by 12 pseudorandom integers stored in the internal uint m[12]; array. Depending on how complicated the way you derive your solution candidates from is, it may be close to impossible to extract your actual solution from just looking at this array. This is the job of our so-called callback.</p>
<p>However, specifying the callback in the metadata is not enough, we need to create that file in the correct location. The directory where callback scripts should be placed into varies by operating system:</p>
<h4 id="macos">MacOS</h4>
<pre><code>~/Library/Application Support/Xeline/callbacks
</code></pre>
<h4 id="windows">Windows</h4>
<pre><code>C:\Users\&lt;YourUserName&gt;\AppData\Local\Xeline\callbacks
</code></pre>
<h4 id="linux">Linux</h4>
<pre><code>~/.config/Xeline/callbacks
</code></pre>
<p>So, if you are on a macOS system you have to create the following file for this demo to run:</p>
<pre><code>~/Library/Application Support/Xeline/
          callbacks/my_own_prime_demo_callback.js
</code></pre>
<p>Callbacks are written in NodeJS and are only executed on your local computer. As said before, they are meant to post process your solution candidate for display. Practically, the Xeline wallet will run this file once a solution has been submitted to the Blockchain and display the console output in your task overview. Of course, your callback can do all sorts of other stuff like, for example, submit your result over the network or feed it into another application. For now, just put this line into the file:</p>
<pre><code>console.log(&quot;Yeah. The blockchain just reported
             this prime: &quot; + (bounties[0][0]&gt;&gt;&gt;0));
</code></pre>
<p>Within your callback script, you can access a two-dimensional array called bounties[][]. The first dimension holds all solutions that were submitted, and the second dimension holds the 12 m[] values that led to this solution. Since we are only looking for one solution only, our bounty array will have just one entry containing twelve unsigned integers:</p>
<pre><code>var bounties = [ [m[0],m[1],m[2],...m[11]] ];
</code></pre>
<p>Since our prime number candidate is just in m[0] (if you do not understand this, reread the ePL programming guide) it is enough for us to print out bounties[0][0], i.e., the first m value in the first (and only) solution.</p>
<p>There is a second, one-dimensional array that you can access, the storages[] array which contains the latest version of the storage integers. Since we have not yet used the concept of iterations and storages, this array will be empty and should not be accessed in this demo.</p>
<h2 id="submittingyourtasktotheblockchain">Submitting Your Task to the Blockchain</h2>
<p>Now, it’s time to submit your task to the Blockchain. To do so, click on “new task” in the lower part of the left-hand side to go to the “New Task” screen:</p>
<p><img src="https://xel.org/content/images/2018/07/xeline_step_1.png" alt="Part 2: Broadcast to the Blockchain"></p>
<p>Now, simply drag your “my_own_prime_demo.epl” file onto the drag-drop field:</p>
<p><img src="https://xel.org/content/images/2018/07/xeline_step_2.png" alt="Part 2: Broadcast to the Blockchain"></p>
<p>You will see a confirmation screen where you can once again verify that all the metadata you have configured earlier has been picked up correctly. Also, this step will inform you in case you have not put your callback script in the proper location. By clicking the “Broadcast” button, you can submit your task to the Blockchain. You will see this confirmation message, showing the transaction ID and advise you to switch over to your task overview:</p>
<p><img src="https://xel.org/content/images/2018/07/xeline_step_3.png" alt="Part 2: Broadcast to the Blockchain"></p>
<p>Click on “work list overview” or on “xx tasks” in the left sidebar to switch to the task overview:</p>
<p><img src="https://xel.org/content/images/2018/07/xeline_step_4.png" alt="Part 2: Broadcast to the Blockchain"></p>
<p>It might happen, that your task does not appear immediately because it needs at least one confirmation on the Blockchain. Just hang on for a minute, it should appear eventually. You will see your task which comes with some basic statistics such as the amount of proof-of-work submissions received so far, the number of bounties (or solutions) that have been found so far, the iteration this job is in and the remaining blocks until the job times out. Additionally, for open tasks, you see a “Cancel” button which allows you to stop that job at any time. Below the task statistics, you see a message saying, that a callback will be executed the moment the job is finished: this is where the results of your task will appear.</p>
<p>So this is how it looks like after your job has finished and your callback has been executed:</p>
<p><img src="https://xel.org/content/images/2018/07/xeline_step_5.png" alt="Part 2: Broadcast to the Blockchain"></p>
<p>Congratulations! You have successfully created your first job in ePL, submitted it to the Blockchain, received a result that has been found by a “miner” and automatically analyzed the result within your callback.</p>
</div>]]></content:encoded></item><item><title><![CDATA[Part 3: Storage and Iterations]]></title><description><![CDATA[This tutorial will take your coding abilities one step further, and expose two of the most powerful features of XEL: storage and iterations.]]></description><link>https://xel.org/storage-and-iterations/</link><guid isPermaLink="false">5b570cb462992e27235e25ce</guid><category><![CDATA[Learn Programming]]></category><dc:creator><![CDATA[Administrator]]></dc:creator><pubDate>Tue, 24 Jul 2018 10:27:00 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1477949331575-2763034b5fb5?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=1080&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ&amp;s=f79bc18d0d05242bec62797027fecb70" medium="image"/><content:encoded><![CDATA[<div class="kg-card-markdown"><h2 id="limitationsoftheoriginaldemo">Limitations of the Original Demo</h2>
<img src="https://images.unsplash.com/photo-1477949331575-2763034b5fb5?ixlib=rb-0.3.5&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ&s=f79bc18d0d05242bec62797027fecb70" alt="Part 3: Storage and Iterations"><p>Our original demo was capable of finding prime numbers between 10000 and 20000. However, there was no way so far on re-using results that have been submitted by other nodes to improve on them. This behavior is for example necessary for Genetic Algorithms. Genetic Algorithms typically use heuristics similar to natural evolution processes like selection and mutation. Candidate solutions to problems that have large search space are then evolved over multiple generations (or iterations, as we would call them). In each generation, the good results of the previous generation are taken and improved causing the Algorithm to converge towards some optimum.</p>
<p>This requires some sort of storage and synchronization between consecutive iterations/generations. We will try to keep things simple in this tutorial for a better understanding. In this tutorial, we want to extend our prime finding demo for it to be able to find multiple primes over multiple iterations, with each prime being smaller than the prime found in the prior iteration.</p>
<p>In order to do so, we adjust our demo to look like this:</p>
<pre><code>// metadata(title:My personal PRIME demo)
// metadata(pow_limit:1000)
// metadata(pow_price:0.2)
// metadata(bounty_limit:1)
// metadata(bounty_price:5)
// metadata(iterations:3)
// metadata(timeout:250)
// metadata(callback:my_own_prime_demo_callback.js)

array_uint 1000;

submit_sz 1;
submit_idx 100;

function main { verify();} 
function primetest {
    u[1] = 0;
    if (u[2] &lt;= 1)  u[1]=0;
    else if (u[2] &lt;= 3) u[1]=0;
    else if (u[2]%2 == 0 || u[2]%3 == 0) u[1]=0;
    else { 
       u[3]=5; u[1]=1;
       repeat(u[99],20000,20000){
          if (u[2]%u[3] == 0 || u[2]%(u[3]+2) == 0)
          { u[1]=0; break; }
          if(u[3]*u[3] &gt; u[2]) break;
                  u[3]+=6;
       }
    }
}

function verify {
    // make prime test
    u[2] = m[0];
    u[1]=0;

    // take over a possible prime stored in s[] storage_idx
    u[4]=s[0];
    u[100]=u[2];

    if(m[0]&gt;10000 &amp;&amp; m[0]&lt;20000 &amp;&amp; (u[4]==0 || m[0]&lt;u[4]))
    primetest();
    // Bounty Is Rewarded:
    // m[0] is larger than 3294967295 and prime
    verify_bty ((m[0]&gt;10000 &amp;&amp; m[0]&lt;20000) &amp;&amp; (u[1]==1));

    // some randomness for POW function
    u[57] = m[1];
    u[56] = m[2];
    u[55] = m[3];
    u[54] = m[4];

    verify_pow (u[57], u[56], u[55], u[54]);
}
</code></pre>
<p>Now, let’s quickly go through the differences:</p>
<pre><code>// metadata(iterations:3)
</code></pre>
<p>This line tells Xeline that we now want three iterations instead of one. The number of solutions (per iterations), in this demo, has been left at one.</p>
<pre><code>submit_sz 1;
submit_idx 100;
</code></pre>
<p>These lines describe that we want a storage size of 1 unsigned integer. When a solution is found, we want the miner to upload submit_sz amount of unsigned integers beginning at u[submit_idx] = u[100].</p>
<pre><code>// take over a possible prime stored in s[] storage_idx
u[4]=s[0];
u[100]=u[2]; // prepare the slot for upload
</code></pre>
<p>In this part, we initialize a free slot in the u-array u[4] with the first and only storage value s[0]. Now, this may sound confusing, so once again. When solutions are found, the miner software submits submit_sz unsigned integers starting from u[submit_idx]. When other miners receive work, that earlier submitted storage is stored in an array called s[] which also has the size of submit_sz. In our case, this means that the value at u[100] (which is initialized with the prime in the code snippet above) is submitted with every solution, and down streamed into s[0] in consecutive iterations. If you have multiple solutions per iteration configured, a random one of those is going to be put into s[0]. This, however, is not the case for this simple demo.</p>
<p>These lines here were also modified:</p>
<pre><code>if(m[0]&gt;10000 &amp;&amp; m[0]&lt;20000 &amp;&amp; (u[4]==0 || m[0]&lt;u[4]))
  primetest();
</code></pre>
<p>On the first iteration, the storage is filled with zero values, and on consecutive iterations, the storage has the value of the previous iteration. What these two lines do is only to run the prime test in case there is no storage yet, or if the prime number in question is smaller than the one submitted to the storage in the previous iteration.</p>
<p>Now, the only thing we have to do, is account for it inside our callback. Since we have three bounties in total, we can just iterate over the first dimension in the bounties array (as described in one of the earlier tutorials):</p>
<pre><code>var txt = (bounties[2][0]&gt;&gt;&gt;0)+&quot;, &quot; +(bounties[1][0]&gt;&gt;&gt;0);
txt +=  &quot;, &quot; +  (bounties[0][0]&gt;&gt;&gt;0);
console.log(&quot;Second demo (three primes): &quot; + txt);
</code></pre>
<p>After you run this in Xeline, you see this result:</p>
<p><img src="https://xel.org/content/images/2018/07/xeline_storage.png" alt="Part 3: Storage and Iterations"></p>
<p>You see that three primes have been found and, by using storage and iterations, every prime number is smaller its predecessor. With the knowledge you have got so far, you can now start programming fancy, multi-iteration tasks for XEL.</p>
</div>]]></content:encoded></item><item><title><![CDATA[Part 4: Using the Mining Software]]></title><description><![CDATA[In this tutorial you will learn how to configure and use the mining software on your computer so you can start contribute your computational power ASAP.]]></description><link>https://xel.org/using-the-miner/</link><guid isPermaLink="false">5b570e0762992e27235e25d1</guid><category><![CDATA[Learn Programming]]></category><dc:creator><![CDATA[Administrator]]></dc:creator><pubDate>Mon, 23 Jul 2018 11:31:00 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1507228060299-33b5fcb63bc6?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=1080&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ&amp;s=636b5941ab53eea2448cb12a7e95c35a" medium="image"/><content:encoded><![CDATA[<div class="kg-card-markdown"><h2 id="usingtheminer">Using the Miner</h2>
<img src="https://images.unsplash.com/photo-1507228060299-33b5fcb63bc6?ixlib=rb-0.3.5&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ&s=636b5941ab53eea2448cb12a7e95c35a" alt="Part 4: Using the Mining Software"><p>Please install the miner first according to the installation manual. Make sure you open up a console and change into the directory where your xel_miner executable is. It is always a good start to have a look at the help information xel_miner provides:</p>
<p>On Linux and macOS, that would be</p>
<pre><code>./xel_miner --help
</code></pre>
<p>On Windows</p>
<pre><code>xel_miner.exe --help
</code></pre>
<p>In the remainder of this tutorial, we will cover the Linux/macOS variant, but the Windows one should always be analogous to that.</p>
<p>We will not cover all options in this tutorial, only those which are required to get your miner ready to work on tasks on the XEL Blockchain. First of all, we want to take a look at the threads configuration parameter:</p>
<pre><code>-t, --threads  Number of miner threads (Default: Number of CPUs)
</code></pre>
<p>This parameter allows you to configure how many threads you want xel_miner to run on. The more threads you use, the faster xel_miner finds solutions. However, if you set this number too high, then your system may become unresponsive.</p>
<p>The next parameter we want to look at is the URL configuration:</p>
<pre><code>-o, --url=URL   URL of mining server
</code></pre>
<p>This allows you to point the miner to either a remote node or a local node. Either way is excellent, but keep in mind that remote URLs do leak your private key to the server at the moment. If you do not trust the remote node, stick to a local one instead. The URL is always given in the form of <a href="http://hostname">http://hostname</a>:port where hostname is the IP or FQDN of the host, and port is either 17876 for the main net or 16876 for the test net.</p>
<p>The third important parameter is the passphrase flag:</p>
<pre><code>-P, --phrase   Secret Passphrase for Elastic account
</code></pre>
<p>This is essential as it specifies the passphrase to the account which will both pay the transactions fees for submitting work results and receive the rewards in exchange. If your passphrase has a space in it, make sure to put double quotes around it. It is essential that you have some initial funds inside this account or you will not be able to submit any solutions. For testing purposes, you can use your 12-word Xeline mnemonic code (enclosed in double quotes) since it’s straightforward to get some XEL from the faucet to get started.</p>
<p>Now, for this tutorial, we want to launch a miner running just one thread, mining via our local node on the test net. Hence, we start it like this:</p>
<pre><code>./xel_miner -t 1 -o http://localhost:16876
            -P &quot;our twelve-word passphrase goes here&quot;
</code></pre>
<p>If you prefer using one of the public nodes, feel free to use one of the balancer nodes instead:</p>
<pre><code>./xel_miner -t 1 -o http://balance-1.xel.org:16876
            -P &quot;our twelve-word passphrase goes here&quot;
</code></pre>
<p>When there is no work on the network, you should see something like this:</p>
<p><img src="https://xel.org/content/images/2018/07/miner_1.png" alt="Part 4: Using the Mining Software"></p>
<p>If this is the case, you should maybe work through one of the other tutorials and post some work to the Blockchain. If you have done so, you should see the miner pick up on your work pretty quickly:</p>
<p><img src="https://xel.org/content/images/2018/07/miner_2.png" alt="Part 4: Using the Mining Software"></p>
<p>The first line means that the maximum number of allowed POWs for this block has already been reached in the unconfirmed transaction cache and there is no need to submit more until the next block arrives. We already know that the retargeting algorithm tries to calibrate the target value so that 10 proof-of-work submissions (on average) are found per minute. This is not per task but for all tasks in the network together. However, as a DOS precaution, there is a hard cap of 25 proof-of-work submissions per block. Once that number is reached, no more proof-of-work submissions are accepted until the next block is found.</p>
<p>The bounty limit behaves similarly. In this scenario, we have a job that takes one bounty per iteration and runs for three iterations. Since one iteration corresponds to at least one full block, there is no need to submit more than one bounty per block. So once a bounty has been found (in this case, this can be more for other tasks), we have to wait until the iteration count increases by one in the next block.</p>
<p>You do not need to monitor the console output continuously. If you launch Xeline, you can see a few basic mining statistics in the left sidebar. Now, you are ready and set to start mining – be it your own tasks for testing purposes or other tasks for some XEL in exchange.</p>
</div>]]></content:encoded></item><item><title><![CDATA[Safely Executing Untrusted Code]]></title><description><![CDATA[Executing code which comes from a potentially untrusted source has never been a good idea. This article shows you why this is not an issue with XEL, and how our system ensures safety and security.]]></description><link>https://xel.org/safely-executing-untrusted-code/</link><guid isPermaLink="false">5b5ad1fd352c821dce608fec</guid><category><![CDATA[Basic Information]]></category><dc:creator><![CDATA[Administrator]]></dc:creator><pubDate>Mon, 23 Jul 2018 08:05:00 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1484814915025-858e00100866?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=1080&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ&amp;s=453aaa9a8c3d972be1e04348401b83d6" medium="image"/><content:encoded><![CDATA[<div class="kg-card-markdown"><img src="https://images.unsplash.com/photo-1484814915025-858e00100866?ixlib=rb-0.3.5&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ&s=453aaa9a8c3d972be1e04348401b83d6" alt="Safely Executing Untrusted Code"><p>It has always been a golden rule: never run any code of untrusted sources on trusted systems. Even manual code checks do not guarantee that there is no hidden, obfuscated malicious section of code included waiting to attack your systems (would you believe it, if I told you that <a href="https://github.com/MinhasKamal/CreepyCodeCollection/blob/master/pi.c">this program</a> calculates PI?). However, also poorly programmed code, even though not malicious, can use up your system's resources and significantly eat away at the performance of your system.</p>
<p>Many other projects that rely on the execution of foreign code do that in a sandboxed environment. Such environments usually provide their storage space and an isolated memory block, which prevents potentially malicious code to eavesdrop on your data, extract sensitive information from other parts of your RAM, or alter your computer in an undesired way. We, however, do not believe this is a viable approach. Not only do you rely on the security of other third-party systems (any vulnerability they built into their product affect you as well) but also the management of resources (and resource allocation) is pretty complicated. I have seen projects in the past, that would not allow you to alter the computer's data but easily allowed for freezing the computer by, e.g., executing an infinite loop or using the computer's network connection to relay all sorts of (potentially illegal) data. We believe that the issue of safely executing foreign code can be solved more elegantly - without the need of one more additional layer and a potential source of error.</p>
<h2 id="xelsprogramminglanguage">XEL's Programming Language</h2>
<p>Our solution to the problems described above is an own programming language - ePL. With ePL, which was explicitly designed for the use on the XEL blockchain, we have managed to ensure safety on the fundamental design-level. It ensures both, safe execution of foreign code on the own computer and reliable verification of the computed results (which assures you that the results other people submit are valid). To dig a bit deeper: ePL is designed as an intermediate language with a radically reduced instruction set. While it comes with a variety of mathematical (and logical) operators and allows for modeling very complex control flows, it lacks any other features that could cause harm to your computer. For example, functions that might be used for accessing the user's hard drive, downloading files from the internet, or executing anything on the host system are not available. Also, due to an analysis on the logic level - these checks are performed for every program - it can be ensured that the programs do not contain any infinite loops or use excessive amounts of resources. While Turing complete languages typically suffer from the &quot;decision problem&quot; - the problem of deciding whether (and when) a program will terminate - our programming language ensures the termination of every program after a certain amount of instructions.</p>
<p>The design of ePL makes it just powerful enough to allow for the implementation of a wide variety of algorithms but yet limits it to safe operations only, guaranteeing that algorithms written in ePL can not eavesdrop on your data or show any other malicious and unwanted behavior. If this sounds too technical for you, picture it as a programming language which just does not have any functions that could even remotely cause any harm to the computer - no network access, no file access, no conditional loops, no gotos, ... just like a programmable calculator which is designed to carry out a particular set of harmless calculations only.</p>
</div>]]></content:encoded></item><item><title><![CDATA[XEL's Payout/Payment Model]]></title><description><![CDATA[XEL has two types of payments. In order to understand how XEL's payments work, we have to shed some light on the entire end-to-end workflow.]]></description><link>https://xel.org/buying-and-selling-computational-resources/</link><guid isPermaLink="false">5b5a7f0e352c821dce608fda</guid><category><![CDATA[Basic Information]]></category><dc:creator><![CDATA[Administrator]]></dc:creator><pubDate>Mon, 23 Jul 2018 02:09:00 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1518544648563-3d99717dbe95?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=1080&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ&amp;s=26348c703b9f92c3362fbe1c0adc6ae7" medium="image"/><content:encoded><![CDATA[<div class="kg-card-markdown"><img src="https://images.unsplash.com/photo-1518544648563-3d99717dbe95?ixlib=rb-0.3.5&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ&s=26348c703b9f92c3362fbe1c0adc6ae7" alt="XEL's Payout/Payment Model"><p>XEL has two types of payments. To understand how XEL's payments work, we have to shed some light on the entire workflow - beginning with the broadcast of a task to the network, to the way miners work on tasks and broadcast the solutions.</p>
<h4 id="theworkflow">The Workflow</h4>
<p>The entire workflow typically starts with scientists composing jobs (or task) which contain all the logic to solve for the actual problem as well as information regarding the rewards being offered to incentivize participation in solving the problem. Then, this job is broadcast to the Blockchain for others to work on.</p>
<p>Once these jobs are available on the Blockchain, these jobs are downloaded by those nodes which contribute their computational resources to the network - let's call them &quot;workers&quot; for now. Workers that find actual solutions – which we also call &quot;bounties&quot; – are rewarded with a &quot;<strong>bounty reward</strong>&quot; by the scientist paid in units of the underlying Crypto-currency. These bounty rewards are set by the scientist when the job is created and should be ideally set to an amount that attracts participation in running their job. As the network grows, competition among scientists to attract participation in running their job increases; therefore, scientists will want to calibrate their bounty rewards to a fair market value to ensure enough interest in their job.</p>
<p>While &quot;bounties&quot; are the primary incentive to attract computation nodes to work on a job, there is a risk that nodes could be working on jobs where no bounty solution even exists. This could be due to an intentional malicious act by the scientist, or simply a bug in the job’s code. To mitigate this risk, scientists will be required to additionally provide &quot;<strong>PoW rewards</strong>&quot;. These PoW are defined as moderately hard tasks which are easily verifiable and which are randomly found by the workers at a certain rate, regardless of how hard or easy the underlying task is, in order ensure workers stay motivated. PoW rewards should be calibrated to roughly match the average electricity cost of running a computational node to alleviate any concerns of participants that they could potentially lose money by running the job. Currently, the network adapts itself so that, on average, 10 PoW payments are made each minute - for all jobs in total, not individually. While the PoW price can be set by the scientist arbitrarily, and will vary among different tasks, it is worth to mention that several tasks might require a higher PoW payment due to a more complex program which needs significantly more time to generate one bounty in relation to other, potentially easier tasks, that are currently alive.</p>
<h4 id="asimplecalculationexample">A Simple Calculation Example</h4>
<p>Imagine there are two jobs active at the moment. Job 1 pays a &quot;bounty&quot; of 100 XEL, and a &quot;PoW reward&quot; of 0.01 XEL. Job 2 pays a &quot;bounty&quot; of 200 XEL, and a &quot;PoW reward&quot; of 0.02 XEL. Also, imagine that one &quot;run&quot; of Job 1 takes 1 second, and one &quot;run&quot; of Job 2 takes 2 seconds (because it is more complex).</p>
<p>On average, every minute there should be a total of 10 PoW rewards in the system. Since you can run Job 1 at twice the speed of Job 2, you will get around 6,66 PoW from Job 1, and 3,33 PoW from Job 2 every minute - that is, roughly, 0.0666 XEL from each of the jobs. Now, if the scientist behind Job 2 had put in a lower PoW reward, you would have no incentive of running his task at all, since sticking to Job 1 would be far more profitable.</p>
<p>In the end, if you solve the actual task and submit the solution, you get 100 XEL from Job 1 and 200 XEL from Job 2. However, there is no guarantee that a solution even exists. Without the periodic payouts of the &quot;PoW bounties,&quot; the incentive to participate would be too low.</p>
</div>]]></content:encoded></item><item><title><![CDATA[Difference to Other Projects]]></title><description><![CDATA[You have not heard about XEL before and you wonder what we are doing different? This article explains why we believe that XEL is the only true super computer out there as of today.]]></description><link>https://xel.org/difference-to-other-projects/</link><guid isPermaLink="false">5b5a7fc0352c821dce608fdd</guid><category><![CDATA[Basic Information]]></category><dc:creator><![CDATA[Administrator]]></dc:creator><pubDate>Sun, 22 Jul 2018 02:14:00 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1523215122-26803239f41f?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=1080&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ&amp;s=561f925629b842fec951a14ea6037fa6" medium="image"/><content:encoded><![CDATA[<div class="kg-card-markdown"><h2 id="anewerabegins">A New Era Begins</h2>
<img src="https://images.unsplash.com/photo-1523215122-26803239f41f?ixlib=rb-0.3.5&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ&s=561f925629b842fec951a14ea6037fa6" alt="Difference to Other Projects"><p>With first ideas publicly emerging in early 2016, XEL has been the pioneer of Blockchain-based grid-computing. While many seemed to have doubts as to whether this technology can work at all, other projects quickly adopted this new idea, that we came up with, and started working on their interpretation of how a Blockchain based computation project should look like.  Now, we are thrilled that we could plant a seed in the Blockchain economy and cause an entirely new niche to develop - one that has never been thought of before.</p>
<h2 id="whatisasupercomputer">What is a Super-Computer</h2>
<p>Before we can elaborate on the differences in the approaches adopted by other projects, we would like to define the term &quot;supercomputer&quot; first. A supercomputer, to us, is a general purpose computer that can prove significantly more computation power than what we can get out of a consumer-grade computer. One way to achieve that is to use the well-researched methodology of grid-computing; that is, the interconnection of many individual computers over a network to bundle their combined computational power into one, holistic pool of computing resources. One strict criterion is the applicability of those resources to a variety of different algorithmic problems. If you wanted to summarize that in three words, you could probably say, that a super-computer is defined by scalability, availability, and flexibility.</p>
<p>XEL's architecture reflects precisely that. Once you broadcast your task to the Blockchain, your task is available to all workers (nodes, that are running the miner to solve your tasks) at once. The bigger the network is, the more computation power is potentially available to you - it scales infinitely with the number of users on the platform. This computational power is available to you at any time, and the integrated programming language, ePL, allows you to code arbitrary tasks that solve problems in your particular research domain. XEL is a decentralized super-computer.</p>
<h2 id="thedirectionofotherprojects">The Direction of Other Projects</h2>
<p>Since the development of a properly working programming language is an arduous task which only a few people master, it is understandable that other projects have chosen a different direction. Since allowing users to code in a traditional, Turing complete language is a no-no (*) (halting problem, malleability, DOS attacks by resource exhausting code, ...), other projects typically focus on a variety of different yet fixed use-cases. That is, these projects code the algorithms themselves, and let the users provide the input. Don't get me wrong, these approaches (that might include rendering tasks, training neural networks, ...) are very helpful to have, yet I would consider them more rendering or machine-learning farms than true versatile super-computers.</p>
<p>(*) (in case of Ethereum, a Turing complete language is fine since you have to deposit a certain amount of gas. Once you run out of gas, the execution terminates - deterministically at the same time for every node that executed that code snippet. This does not work for computation engines where people execute different (non-deterministic) parts of the program, and where it is desired to execute the entire code until the end.</p>
<h2 id="theissueofverification">The Issue of Verification</h2>
<p>Typically, the idea of a Blockchain-based super-computer is that you pay for others to solve your tasks and return the solution to you. Moreover, because you pay, you certainly want to make damn sure that you get the correct result. Well, XEL has solved that very issue pretty elegantly. The ePL language, as you will learn in the programming tutorial, has a beautiful property that allows the scientist, those who programmed the job, to introduce a verification function. If that verification is not passed, the result will not even be broadcasted by the network. All the solutions that you receive, therefore, can be seen as verified and correct.</p>
<p>This is not easy to do when you rely on specific use-cases like rendering or machine learning. Contrary to XEL, which runs the code natively, other projects typically use virtual machines (such as Docker) fitted with a third-party rendering engine or machine learning environment. These software tools are so complex that they do not only add a potential source of error, but they do not necessarily produce the same outputs when running on different machines. So if I render a picture on my computer, and you render the same picture on your computer, the two results might be just not binary identical. That makes verification very hard. Besides, there is no way to specify how the result should look like beforehand. You can tell XEL how to verify whether a result indeed evaluates a complicated formula to zero, but you have no chance to specify how a correctly rendered image would look like - you don't even know until you see it - leaving you just the option of probabilistic verification (as in verifying a small portion of the image). Malicious workers have a clear incentive here to only carry out a portion of the job (low quality or incomplete rendering, lousy training, ...), just enough, so it slips through current &quot;probabilistic&quot; verification methods, so they get paid.</p>
<p>In summary, work verification is a complex issue that XEL does not have, and that we think has yet to be solved by other projects. We are very interested to see how the first real solution will look like, since it is a tough issue to solve, and we hope that it won't include a <strong>centralized watchdog</strong>.</p>
<h2 id="locking">Locking</h2>
<p>Since rendering or training a DNN is a very resource intensive tasks, other projects usually have to &quot;assign&quot; individual tasks to individual nodes and only allow this one individual node to work on it. This is the right thing to do because nobody wants to work for 2 hours on a render job only to find out that someone else was quicker. However, this also has one potential drawback: what happens with very slow nodes or nodes that acquire a lock but leave? Such behavior can cause the task to run significantly longer than it would on the own (low grade) home computer. Also, in how many slices do you cut those jobs and how many locks do you offer? This number certainly limits the amount of computation power you can get out of it at all. If a task can only be cut into 100 individual pieces (because a smaller denomination would add too much overhead compared to the size of each piece), then you will only get 100 nodes working on your task at most - no matter if the network has 100 or 100,000,000 nodes active. XEL does not have this problem since the computational power of all 100,000,000 nodes would be available at once. This is possible due to how ePL is designed (one iteration of each program runs a few seconds at most) and how it allowed avoiding any locking at all (the search space is designed so large that it is unlikely that two nodes will work on the same task simultaneously).</p>
<h2 id="hostingdatabaseswebsites">Hosting Databases, Websites, ...</h2>
<p>Well, I am sure that there are certainly use-cases for that. But how is this supposed to calculate my monte carlo simulation? This certainly is no super-computer.</p>
</div>]]></content:encoded></item><item><title><![CDATA[Debunked: You Are Not Investing]]></title><description><![CDATA[Since we achieved a milestone and got one step closer to mainstream adoption, a strange misconception has spouted across the entire crypto community: crypto currencies are NOT investments]]></description><link>https://xel.org/you-are-not-investing/</link><guid isPermaLink="false">5b5aedea352c821dce608fef</guid><category><![CDATA[Basic Information]]></category><dc:creator><![CDATA[Administrator]]></dc:creator><pubDate>Wed, 18 Jul 2018 10:02:00 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1483129804960-cb1964499894?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=1080&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ&amp;s=581883f415ea39c5823337f774c51138" medium="image"/><content:encoded><![CDATA[<div class="kg-card-markdown"><img src="https://images.unsplash.com/photo-1483129804960-cb1964499894?ixlib=rb-0.3.5&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ&s=581883f415ea39c5823337f774c51138" alt="Debunked: You Are Not Investing"><p>Since we achieved a milestone and got one step closer to mainstream adoption, a strange misconception has spouted across the entire crypto community. The influx of new members, who are keen to get their hands on this beautiful, new technology called Blockchain, has allowed for a new, secret society of self-proclaimed &quot;investors&quot; to emerge.</p>
<p>At this point, we would like to point out, that buying a cryptocurrency token is not an investment per se; neither is the purchase of a rare baseball card, gold, or Beanie Babies. You indeed do not own a portion of Ty Inc just because you have a brand new Beanie Babie sitting on your desk, do you?</p>
<p>An investment typically is considered a financial instrument that is going to generate some reasonably expected income. That could involve the purchase of stocks, which give you the ownership of a little portion of a company and give you the right to a portion of the company's value. An investment could also mean the purchase of real estate, which can generate a steady income while preserving your initial investment. There are also lending investments, where you invest in a loan and make a profit from the interest payments of the counterparty.</p>
<p>Buying a cryptocurrency, however, is NOT an investment. Typically, cryptocurrencies are bought on so-called coin exchanges, where buyers and sellers are brought together by some market matching algorithm. So, when you go to an exchange and purchase any cryptocurrency, you are not buying it from any specific company (much less from the &quot;core developers&quot;). You are buying it from some random person on the internet that, at that very moment, just decided to sell his coins. You are not buying anything from any centralized company, and even less so does anyone promise you anything for your purchase.</p>
<p>While there are indeed some so-called &quot;security tokens&quot; which guarantee your participation in some company proportional to how many coins you hold, this by no means applies to all cryptocurrencies. Certainly not to XEL. In the general case, holding a cryptocurrency token or coin can be used to interact with the platform. Due to the decentralized nature of Blockchain projects, however, nobody can guarantee you whether the platform will change, will be adopted by many users, or whether it will evaporate into the ether because a new, better project emerges in the future. Nobody can and will give any of these guarantees. Crystal balls have not been invented yet. Besides, it's common sense, that a &quot;decentralized system&quot; and &quot;expecting promises from a central party&quot; don't go well together in the first place.</p>
<p>To be safe, and this applies to all cryptocurrencies: if you want to use a platform, feel free to get some coins from someone (check if it is legal in your jurisdiction first) and use them. However, do not buy any coins to &quot;invest&quot; - that would be speculation (or gambling) at most, and you will be disappointed if things develop differently from what you expected.</p>
</div>]]></content:encoded></item></channel></rss>